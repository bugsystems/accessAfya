import * as tslib_1 from "tslib";
import * as React from 'react';
import prefixes from './PrefixManager';
var viewportClassPrefix = function (viewport) { return (viewport === 'xs' ? '' : '-' + viewport); };
var flexAlignment = {
    row: {
        direction: function (viewport) { return prefixes.column + "flex" + viewportClassPrefix(viewport) + "-column"; },
        vertical: {
            top: function (viewport) {
                return prefixes.column + "justify-content" + viewportClassPrefix(viewport) + "-start " + prefixes.column + "align-self" + viewportClassPrefix(viewport) + "-start";
            },
            center: function (viewport) {
                return prefixes.column + "justify-content" + viewportClassPrefix(viewport) + "-center " + prefixes.column + "align-self" + viewportClassPrefix(viewport) + "-center";
            },
            bottom: function (viewport) {
                return prefixes.column + "justify-content" + viewportClassPrefix(viewport) + "-end " + prefixes.column + "align-self" + viewportClassPrefix(viewport) + "-end";
            },
            justify: function (viewport) {
                return prefixes.column + "justify-content" + viewportClassPrefix(viewport) + "-between " + prefixes.column + "align-self" + viewportClassPrefix(viewport) + "-stretch";
            },
        },
    },
    col: {
        direction: function (viewport) { return prefixes.column + "flex" + viewportClassPrefix(viewport) + "-row"; },
        vertical: {
            top: function (viewport) {
                return prefixes.column + "align-self" + viewportClassPrefix(viewport) + "-start " + prefixes.column + "justify-content" + viewportClassPrefix(viewport) + "-start";
            },
            center: function (viewport) {
                return prefixes.column + "align-self" + viewportClassPrefix(viewport) + "-center " + prefixes.column + "justify-content" + viewportClassPrefix(viewport) + "-start";
            },
            bottom: function (viewport) {
                return prefixes.column + "align-self" + viewportClassPrefix(viewport) + "-end " + prefixes.column + "justify-content" + viewportClassPrefix(viewport) + "-start";
            },
            justify: function (viewport) {
                return prefixes.column + "align-self" + viewportClassPrefix(viewport) + "-stretch " + prefixes.column + "justify-content" + viewportClassPrefix(viewport) + "-start";
            },
        },
    },
    horizontal: {
        left: function (viewport) {
            return prefixes.column + "ml" + viewportClassPrefix(viewport) + "-0 " + prefixes.column + "mr" + viewportClassPrefix(viewport) + "-auto " + prefixes.column + "w" + viewportClassPrefix(viewport) + "-auto";
        },
        right: function (viewport) {
            return prefixes.column + "ml" + viewportClassPrefix(viewport) + "-auto " + prefixes.column + "mr" + viewportClassPrefix(viewport) + "-0 " + prefixes.column + "w" + viewportClassPrefix(viewport) + "-auto";
        },
        center: function (viewport) {
            return prefixes.column + "ml" + viewportClassPrefix(viewport) + "-auto " + prefixes.column + "mr" + viewportClassPrefix(viewport) + "-auto " + prefixes.column + "w" + viewportClassPrefix(viewport) + "-auto";
        },
        stretch: function (viewport) {
            return prefixes.column + "ml" + viewportClassPrefix(viewport) + "-0 " + prefixes.column + "mr" + viewportClassPrefix(viewport) + "-0 " + prefixes.column + "w" + viewportClassPrefix(viewport) + "-100";
        },
    },
};
function getDirectionForBreakpoints(directionBreakpoints) {
    var lastBreakpoint = directionBreakpoints.xs || 'row';
    var breakpointDirections = {
        xs: lastBreakpoint,
    };
    ['sm', 'md', 'lg', 'xl'].forEach(function (viewport) {
        breakpointDirections[viewport] = directionBreakpoints[viewport] || lastBreakpoint;
        lastBreakpoint = breakpointDirections[viewport];
    });
    return breakpointDirections;
}
function populateOuterClasses(sizeBreakpointsName, breakpointSize) {
    var outerClassNames = [];
    if (breakpointSize === 0) {
        outerClassNames.push(prefixes.row + "d" + viewportClassPrefix(sizeBreakpointsName) + "-none");
    }
    else {
        outerClassNames.push(prefixes.row + "d" + viewportClassPrefix(sizeBreakpointsName) + "-flex");
        var className = breakpointSize === undefined
            ? prefixes.row + "col"
            : prefixes.row + "col" + viewportClassPrefix(sizeBreakpointsName) + "-" + breakpointSize;
        outerClassNames.push(className);
    }
    return outerClassNames;
}
function populatePlacementClasses(offsetBreakpoints, placement) {
    var classNames = [];
    Object.keys(offsetBreakpoints).forEach(function (offsetBreakpointName) {
        var breakpointSize = offsetBreakpoints[offsetBreakpointName];
        classNames.push("" + prefixes.row + placement + viewportClassPrefix(offsetBreakpointName) + "-" + breakpointSize);
    });
    return classNames;
}
function getClassName(breakpointName, breakpointAlignment, orientation, flexDirection) {
    var className = '';
    if (flexAlignment[flexDirection][orientation]) {
        className = flexAlignment[flexDirection][orientation][breakpointAlignment](breakpointName);
    }
    else {
        className = flexAlignment[orientation][breakpointAlignment](breakpointName);
    }
    return className;
}
function populateInnerClasses(alignmentBreakpoints, calculatedFlexDirections, orientation) {
    var innerClassName = [];
    Object.keys(alignmentBreakpoints).forEach(function (breakpointName) {
        var flexDirection = calculatedFlexDirections[breakpointName];
        var breakpointAlignment = alignmentBreakpoints[breakpointName];
        if (breakpointAlignment) {
            var appointedClassName = getClassName(breakpointName, breakpointAlignment, orientation, flexDirection);
            innerClassName.push(appointedClassName);
        }
    });
    return innerClassName;
}
var Column = /** @class */ (function (_super) {
    tslib_1.__extends(Column, _super);
    function Column() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Column.prototype.render = function () {
        var _a = this.props, size = _a.size, direction = _a.direction, verticalAlignment = _a.verticalAlignment, horizontalAlignment = _a.horizontalAlignment, offset = _a.offset, order = _a.order, className = _a.className;
        var sizeBreakpoints = typeof size === 'number' ? { xs: size } : size || {};
        var directionBreakpoints = typeof direction === 'string' ? { xs: direction } : direction || {};
        var verticalAlignmentBreakpoints = typeof verticalAlignment === 'string' ? { xs: verticalAlignment } : verticalAlignment || {};
        var horizontalAlignmentBreakpoints = typeof horizontalAlignment === 'string' ? { xs: horizontalAlignment } : horizontalAlignment || {};
        var offsetBreakpoints = typeof offset === 'number' ? { xs: offset } : offset || {};
        var orderBreakpoints = typeof order === 'number' || typeof order === 'string' ? { xs: order } : order || {};
        if (!sizeBreakpoints.xs && sizeBreakpoints.xs !== 0) {
            sizeBreakpoints.xs = undefined;
        }
        if (!directionBreakpoints.xs) {
            directionBreakpoints.xs = 'row';
        }
        if (!verticalAlignmentBreakpoints.xs) {
            verticalAlignmentBreakpoints.xs = 'top';
        }
        if (!horizontalAlignmentBreakpoints.xs) {
            horizontalAlignmentBreakpoints.xs = 'stretch';
        }
        var outerClassName = className ? [className] : [];
        var innerClassName = [prefixes.column + "d-flex"];
        Object.keys(sizeBreakpoints).forEach(function (sizeBreakpointsName) {
            var breakpointSize = sizeBreakpoints[sizeBreakpointsName];
            var outerClassNames = populateOuterClasses(sizeBreakpointsName, breakpointSize);
            outerClassName.push.apply(outerClassName, outerClassNames);
        });
        Object.keys(directionBreakpoints).forEach(function (directionBreakpointName) {
            var breakpointDirection = directionBreakpoints[directionBreakpointName];
            if (breakpointDirection) {
                innerClassName.push(flexAlignment[breakpointDirection].direction(directionBreakpointName));
            }
        });
        var offsetOuterClassNames = populatePlacementClasses(offsetBreakpoints, 'offset');
        var orderOuterClassNames = populatePlacementClasses(orderBreakpoints, 'order');
        outerClassName.push.apply(outerClassName, offsetOuterClassNames.concat(orderOuterClassNames));
        var calculatedFlexDirections = getDirectionForBreakpoints(directionBreakpoints);
        var verticalInnerClassNames = populateInnerClasses(verticalAlignmentBreakpoints, calculatedFlexDirections, 'vertical');
        var horizontalInnerClassNames = populateInnerClasses(horizontalAlignmentBreakpoints, calculatedFlexDirections, 'horizontal');
        innerClassName.push.apply(innerClassName, verticalInnerClassNames.concat(horizontalInnerClassNames));
        return (React.createElement("div", { className: outerClassName.join(' ').trim() },
            React.createElement("div", { className: innerClassName.join(' ').trim() }, this.props.children)));
    };
    return Column;
}(React.PureComponent));
export { Column };
//# sourceMappingURL=Column.js.map