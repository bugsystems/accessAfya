{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport * as React from 'react';\nimport prefixes from './PrefixManager';\n\nvar viewportClassPrefix = function (viewport) {\n  return viewport === 'xs' ? '' : '-' + viewport;\n};\n\nfunction setAlignment(alignmentValue) {\n  return typeof alignmentValue === 'string' ? {\n    xs: alignmentValue\n  } : alignmentValue || {};\n}\n\nfunction populateClasses(alignmentBreakpointsType, propertyName) {\n  var classNames = [];\n  Object.keys(alignmentBreakpointsType).forEach(function (breakpointName) {\n    var breakpointValue = alignmentBreakpointsType[breakpointName];\n    classNames.push(\"\" + prefixes.column + propertyName + viewportClassPrefix(breakpointName) + \"-\" + breakpointValue);\n  });\n  return classNames;\n}\n\nvar Row =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Row, _super);\n\n  function Row() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Row.prototype.render = function () {\n    var _a = this.props,\n        verticalAlignment = _a.verticalAlignment,\n        horizontalAlignment = _a.horizontalAlignment,\n        noGutters = _a.noGutters;\n    var classNames = [prefixes.row + \"row\"];\n    var verticalAlignmentBreakpoints = setAlignment(verticalAlignment);\n    var horizontalAlignmentBreakpoints = setAlignment(horizontalAlignment);\n\n    if (verticalAlignment) {\n      var verticalAlignmentClassNames = populateClasses(verticalAlignmentBreakpoints, 'align-items');\n      classNames.push.apply(classNames, verticalAlignmentClassNames);\n    }\n\n    if (horizontalAlignment) {\n      var horizontalAlignmentClassNames = populateClasses(horizontalAlignmentBreakpoints, 'justify-content');\n      classNames.push.apply(classNames, horizontalAlignmentClassNames);\n    }\n\n    if (noGutters) {\n      classNames.push(prefixes.row + \"no-gutters\");\n    }\n\n    return React.createElement(\"div\", {\n      className: classNames.join(' ')\n    }, this.props.children);\n  };\n\n  return Row;\n}(React.Component);\n\nexport { Row };","map":{"version":3,"sources":["../src/components/Row.tsx"],"names":[],"mappings":";AAAA,OAAO,KAAK,KAAZ,MAAuB,OAAvB;AAEA,OAAO,QAAP,MAAqB,iBAArB;;AAgCA,IAAM,mBAAmB,GAAG,UAAC,QAAD,EAAmB;AAAK,SAAC,QAAQ,KAAK,IAAb,GAAoB,EAApB,GAAyB,MAA1B,QAAA;AAAyC,CAA7F;;AAEA,SAAS,YAAT,CAAsB,cAAtB,EAAoD;AACnD,SAAO,OAAO,cAAP,KAA0B,QAA1B,GAAqC;AAAE,IAAA,EAAE,EAAE;AAAN,GAArC,GAA8D,cAAc,IAAI,EAAvF;AACA;;AAED,SAAS,eAAT,CACC,wBADD,EAEC,YAFD,EAEqB;AAEpB,MAAM,UAAU,GAAa,EAA7B;AACA,EAAA,MAAM,CAAC,IAAP,CAAY,wBAAZ,EAAsC,OAAtC,CAA8C,UAAC,cAAD,EAAsD;AACnG,QAAM,eAAe,GAAG,wBAAwB,CAAC,cAAD,CAAhD;AAEA,IAAA,UAAU,CAAC,IAAX,CAAgB,KAAG,QAAQ,CAAC,MAAZ,GAAqB,YAArB,GAAoC,mBAAmB,CAAC,cAAD,CAAvD,GAAuE,GAAvE,GAA2E,eAA3F;AACA,GAJD;AAKA,SAAO,UAAP;AACA;;AAED,IAAA,GAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAAyB,EAAA,OAAA,CAAA,SAAA,CAAA,GAAA,EAAA,MAAA;;AAAzB,WAAA,GAAA,GAAA;;AAuBC;;AAtBO,EAAA,GAAA,CAAA,SAAA,CAAA,MAAA,GAAP,YAAA;AACO,QAAA,EAAA,GAAA,KAAA,KAAA;AAAA,QAAE,iBAAA,GAAA,EAAA,CAAA,iBAAF;AAAA,QAAqB,mBAAA,GAAA,EAAA,CAAA,mBAArB;AAAA,QAA0C,SAAA,GAAA,EAAA,CAAA,SAA1C;AACN,QAAM,UAAU,GAAG,CAAI,QAAQ,CAAC,GAAT,GAAY,KAAhB,CAAnB;AACA,QAAM,4BAA4B,GAAG,YAAY,CAAC,iBAAD,CAAjD;AACA,QAAM,8BAA8B,GAAG,YAAY,CAAC,mBAAD,CAAnD;;AAEA,QAAI,iBAAJ,EAAuB;AACtB,UAAM,2BAA2B,GAAG,eAAe,CAAC,4BAAD,EAA+B,aAA/B,CAAnD;AACA,MAAA,UAAU,CAAC,IAAX,CAAe,KAAf,CAAA,UAAA,EAAmB,2BAAnB;AACA;;AAED,QAAI,mBAAJ,EAAyB;AACxB,UAAM,6BAA6B,GAAG,eAAe,CAAC,8BAAD,EAAiC,iBAAjC,CAArD;AACA,MAAA,UAAU,CAAC,IAAX,CAAe,KAAf,CAAA,UAAA,EAAmB,6BAAnB;AACA;;AAED,QAAI,SAAJ,EAAe;AACd,MAAA,UAAU,CAAC,IAAX,CAAmB,QAAQ,CAAC,GAAT,GAAY,YAA/B;AACA;;AAED,WAAO,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA;AAAK,MAAA,SAAS,EAAE,UAAU,CAAC,IAAX,CAAgB,GAAhB;AAAhB,KAAA,EAAuC,KAAK,KAAL,CAAW,QAAlD,CAAP;AACA,GArBM;;AAsBR,SAAA,GAAA;AAAC,CAvBD,CAAyB,KAAK,CAAC,SAA/B,CAAA","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport * as React from 'react';\nimport prefixes from './PrefixManager';\nvar viewportClassPrefix = function (viewport) { return (viewport === 'xs' ? '' : '-' + viewport); };\nfunction setAlignment(alignmentValue) {\n    return typeof alignmentValue === 'string' ? { xs: alignmentValue } : alignmentValue || {};\n}\nfunction populateClasses(alignmentBreakpointsType, propertyName) {\n    var classNames = [];\n    Object.keys(alignmentBreakpointsType).forEach(function (breakpointName) {\n        var breakpointValue = alignmentBreakpointsType[breakpointName];\n        classNames.push(\"\" + prefixes.column + propertyName + viewportClassPrefix(breakpointName) + \"-\" + breakpointValue);\n    });\n    return classNames;\n}\nvar Row = /** @class */ (function (_super) {\n    tslib_1.__extends(Row, _super);\n    function Row() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Row.prototype.render = function () {\n        var _a = this.props, verticalAlignment = _a.verticalAlignment, horizontalAlignment = _a.horizontalAlignment, noGutters = _a.noGutters;\n        var classNames = [prefixes.row + \"row\"];\n        var verticalAlignmentBreakpoints = setAlignment(verticalAlignment);\n        var horizontalAlignmentBreakpoints = setAlignment(horizontalAlignment);\n        if (verticalAlignment) {\n            var verticalAlignmentClassNames = populateClasses(verticalAlignmentBreakpoints, 'align-items');\n            classNames.push.apply(classNames, verticalAlignmentClassNames);\n        }\n        if (horizontalAlignment) {\n            var horizontalAlignmentClassNames = populateClasses(horizontalAlignmentBreakpoints, 'justify-content');\n            classNames.push.apply(classNames, horizontalAlignmentClassNames);\n        }\n        if (noGutters) {\n            classNames.push(prefixes.row + \"no-gutters\");\n        }\n        return React.createElement(\"div\", { className: classNames.join(' ') }, this.props.children);\n    };\n    return Row;\n}(React.Component));\nexport { Row };\n//# sourceMappingURL=Row.js.map"]},"metadata":{},"sourceType":"module"}